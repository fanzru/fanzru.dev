---
title: "TypeScript Design Patterns in React"
date: "2024-03-14"
category: "Development"
excerpt: "Learn essential TypeScript patterns and best practices for building type-safe React applications, including component patterns, hooks, and state management."
---

# TypeScript Design Patterns in React

TypeScript has become the standard for building large-scale React applications. In this guide, we'll explore common patterns and best practices for using TypeScript with React effectively.

## Why TypeScript with React?

TypeScript offers several benefits for React development:

- **Type Safety** for props and state
- Better **IDE support** and autocompletion
- **Early error detection**
- Improved **code maintainability**
- Enhanced **refactoring** capabilities

## Setting Up Your Project

Create a new React project with TypeScript:

```bash
npx create-react-app my-app --template typescript
cd my-app
```

### Project Structure

A typical React TypeScript project structure:

```text
my-app/
  ├── src/
  │   ├── components/
  │   ├── hooks/
  │   ├── types/
  │   └── utils/
  ├── tsconfig.json
  └── package.json
```

## Component Patterns

### Functional Components with Props

```tsx
interface UserProps {
  name: string;
  email: string;
  age?: number;
}

const UserProfile: React.FC<UserProps> = ({ name, email, age }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
      {age && <p>Age: {age}</p>}
    </div>
  );
};
```

### Generic Components

```tsx
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

## Custom Hooks

Creating type-safe custom hooks:

```tsx
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue] as const;
}
```

## Performance Optimization

Here are some tips for optimizing your React TypeScript application:

1. Use Memo for Complex Components

```tsx
interface ExpensiveComponentProps {
  data: ExpensiveData;
  onUpdate: (id: string) => void;
}

const ExpensiveComponent = React.memo<ExpensiveComponentProps>(
  ({ data, onUpdate }) => {
    return (
      // Component implementation
    );
  }
);
```

2. Implement Proper Event Types

```tsx
interface ButtonProps {
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
  children: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({ onClick, children }) => {
  return <button onClick={onClick}>{children}</button>;
};
```

## Conclusion

TypeScript enhances React development by providing type safety and better tooling. By following these patterns and best practices, you can build more maintainable and robust React applications.
